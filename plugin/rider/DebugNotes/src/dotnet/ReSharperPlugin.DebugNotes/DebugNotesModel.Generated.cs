//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.13.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace ReSharperPlugin.DebugNotes.Rider.Model
{
  
  
  /// <summary>
  /// <p>Generated from: DebugNotesModel.kt:10</p>
  /// </summary>
  public class DebugNotesModel : RdExtBase
  {
    //fields
    //public fields
    [NotNull] public ISignal<ReSharperPlugin.DebugNotes.Rider.Model.Call> Call => _Call;
    [NotNull] public ISignal<MethodStructure> Method => _Method;
    [NotNull] public ISignal<MethodStructure> NavigateMethod => _NavigateMethod;
    [NotNull] public ISignal<ClassStructure> NavigateClass => _NavigateClass;
    
    //private fields
    [NotNull] private readonly RdSignal<ReSharperPlugin.DebugNotes.Rider.Model.Call> _Call;
    [NotNull] private readonly RdSignal<MethodStructure> _Method;
    [NotNull] private readonly RdSignal<MethodStructure> _NavigateMethod;
    [NotNull] private readonly RdSignal<ClassStructure> _NavigateClass;
    
    //primary constructor
    private DebugNotesModel(
      [NotNull] RdSignal<ReSharperPlugin.DebugNotes.Rider.Model.Call> call,
      [NotNull] RdSignal<MethodStructure> method,
      [NotNull] RdSignal<MethodStructure> navigateMethod,
      [NotNull] RdSignal<ClassStructure> navigateClass
    )
    {
      if (call == null) throw new ArgumentNullException("call");
      if (method == null) throw new ArgumentNullException("method");
      if (navigateMethod == null) throw new ArgumentNullException("navigateMethod");
      if (navigateClass == null) throw new ArgumentNullException("navigateClass");
      
      _Call = call;
      _Method = method;
      _NavigateMethod = navigateMethod;
      _NavigateClass = navigateClass;
      BindableChildren.Add(new KeyValuePair<string, object>("call", _Call));
      BindableChildren.Add(new KeyValuePair<string, object>("method", _Method));
      BindableChildren.Add(new KeyValuePair<string, object>("navigateMethod", _NavigateMethod));
      BindableChildren.Add(new KeyValuePair<string, object>("navigateClass", _NavigateClass));
    }
    //secondary constructor
    internal DebugNotesModel (
    ) : this (
      new RdSignal<ReSharperPlugin.DebugNotes.Rider.Model.Call>(ReSharperPlugin.DebugNotes.Rider.Model.Call.Read, ReSharperPlugin.DebugNotes.Rider.Model.Call.Write),
      new RdSignal<MethodStructure>(MethodStructure.Read, MethodStructure.Write),
      new RdSignal<MethodStructure>(MethodStructure.Read, MethodStructure.Write),
      new RdSignal<ClassStructure>(ClassStructure.Read, ClassStructure.Write)
    ) {}
    //deconstruct trait
    //statics
    
    
    
    protected override long SerializationHash => -5213528070320023201L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      
      serializers.RegisterToplevelOnce(typeof(JetBrains.Rider.Model.IdeRoot), JetBrains.Rider.Model.IdeRoot.RegisterDeclaredTypesSerializers);
    }
    
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("DebugNotesModel (");
      using (printer.IndentCookie()) {
        printer.Print("call = "); _Call.PrintEx(printer); printer.Println();
        printer.Print("method = "); _Method.PrintEx(printer); printer.Println();
        printer.Print("navigateMethod = "); _NavigateMethod.PrintEx(printer); printer.Println();
        printer.Print("navigateClass = "); _NavigateClass.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  public static class SolutionDebugNotesModelEx
   {
    public static DebugNotesModel GetDebugNotesModel(this JetBrains.Rider.Model.Solution solution)
    {
      return solution.GetOrCreateExtension("debugNotesModel", () => new DebugNotesModel());
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DebugNotesModel.kt:23</p>
  /// </summary>
  public sealed class Call : IPrintable, IEquatable<Call>
  {
    //fields
    //public fields
    [NotNull] public MethodStructure Method {get; private set;}
    [NotNull] public MethodStructure Parent {get; private set;}
    
    //private fields
    //primary constructor
    public Call(
      [NotNull] MethodStructure method,
      [NotNull] MethodStructure parent
    )
    {
      if (method == null) throw new ArgumentNullException("method");
      if (parent == null) throw new ArgumentNullException("parent");
      
      Method = method;
      Parent = parent;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out MethodStructure method, [NotNull] out MethodStructure parent)
    {
      method = Method;
      parent = Parent;
    }
    //statics
    
    public static CtxReadDelegate<Call> Read = (ctx, reader) => 
    {
      var method = MethodStructure.Read(ctx, reader);
      var parent = MethodStructure.Read(ctx, reader);
      var _result = new Call(method, parent);
      return _result;
    };
    
    public static CtxWriteDelegate<Call> Write = (ctx, writer, value) => 
    {
      MethodStructure.Write(ctx, writer, value.Method);
      MethodStructure.Write(ctx, writer, value.Parent);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Call) obj);
    }
    public bool Equals(Call other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Equals(Method, other.Method) && Equals(Parent, other.Parent);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Method.GetHashCode();
        hash = hash * 31 + Parent.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("Call (");
      using (printer.IndentCookie()) {
        printer.Print("method = "); Method.PrintEx(printer); printer.Println();
        printer.Print("parent = "); Parent.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DebugNotesModel.kt:18</p>
  /// </summary>
  public sealed class ClassStructure : IPrintable, IEquatable<ClassStructure>
  {
    //fields
    //public fields
    [NotNull] public string Namespace {get; private set;}
    [NotNull] public string ClassName {get; private set;}
    
    //private fields
    //primary constructor
    public ClassStructure(
      [NotNull] string @namespace,
      [NotNull] string className
    )
    {
      if (@namespace == null) throw new ArgumentNullException("namespace");
      if (className == null) throw new ArgumentNullException("className");
      
      Namespace = @namespace;
      ClassName = className;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string @namespace, [NotNull] out string className)
    {
      @namespace = Namespace;
      className = ClassName;
    }
    //statics
    
    public static CtxReadDelegate<ClassStructure> Read = (ctx, reader) => 
    {
      var @namespace = reader.ReadString();
      var className = reader.ReadString();
      var _result = new ClassStructure(@namespace, className);
      return _result;
    };
    
    public static CtxWriteDelegate<ClassStructure> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Namespace);
      writer.Write(value.ClassName);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((ClassStructure) obj);
    }
    public bool Equals(ClassStructure other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Namespace == other.Namespace && ClassName == other.ClassName;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Namespace.GetHashCode();
        hash = hash * 31 + ClassName.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("ClassStructure (");
      using (printer.IndentCookie()) {
        printer.Print("namespace = "); Namespace.PrintEx(printer); printer.Println();
        printer.Print("className = "); ClassName.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DebugNotesModel.kt:12</p>
  /// </summary>
  public sealed class MethodStructure : IPrintable, IEquatable<MethodStructure>
  {
    //fields
    //public fields
    [NotNull] public string Namespace {get; private set;}
    [NotNull] public string ClassName {get; private set;}
    [NotNull] public string MethodName {get; private set;}
    
    //private fields
    //primary constructor
    public MethodStructure(
      [NotNull] string @namespace,
      [NotNull] string className,
      [NotNull] string methodName
    )
    {
      if (@namespace == null) throw new ArgumentNullException("namespace");
      if (className == null) throw new ArgumentNullException("className");
      if (methodName == null) throw new ArgumentNullException("methodName");
      
      Namespace = @namespace;
      ClassName = className;
      MethodName = methodName;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string @namespace, [NotNull] out string className, [NotNull] out string methodName)
    {
      @namespace = Namespace;
      className = ClassName;
      methodName = MethodName;
    }
    //statics
    
    public static CtxReadDelegate<MethodStructure> Read = (ctx, reader) => 
    {
      var @namespace = reader.ReadString();
      var className = reader.ReadString();
      var methodName = reader.ReadString();
      var _result = new MethodStructure(@namespace, className, methodName);
      return _result;
    };
    
    public static CtxWriteDelegate<MethodStructure> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Namespace);
      writer.Write(value.ClassName);
      writer.Write(value.MethodName);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((MethodStructure) obj);
    }
    public bool Equals(MethodStructure other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Namespace == other.Namespace && ClassName == other.ClassName && MethodName == other.MethodName;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Namespace.GetHashCode();
        hash = hash * 31 + ClassName.GetHashCode();
        hash = hash * 31 + MethodName.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("MethodStructure (");
      using (printer.IndentCookie()) {
        printer.Print("namespace = "); Namespace.PrintEx(printer); printer.Println();
        printer.Print("className = "); ClassName.PrintEx(printer); printer.Println();
        printer.Print("methodName = "); MethodName.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
}
